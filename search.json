[
  {
    "objectID": "prc.html",
    "href": "prc.html",
    "title": "PRC",
    "section": "",
    "text": "from circadian.lights import *\nimport numpy as np\nfrom circadian.models import * \nimport matplotlib.pyplot as plt\n\n\nsource\n\nRimmerLightPulseLight\n\n RimmerLightPulseLight ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nPhaseResponseCurveLight\n\n PhaseResponseCurveLight ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nPRCFinder\n\n PRCFinder ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nheaviside\n\n heaviside (x:float)\n\n\nmodel = Hannay19()\n\nlight_func =Light.RegularLight(lux=1000.0)\nts = np.arange(0.0, 24.0,0.10) \nlight_values = light_func(ts, repeat_period=24.0)\ninitial_conditions = model.initial_conditions_loop(ts, light_est=light_values, num_loops=100)\n\nphases = [] \nshifts = [] \nfor cr in PRCFinder().type0x:\n    phase,shift = PRCFinder.prc_type0_point(cr, initial_conditions, model)\n    phases.append(phase)\n    if shift> 12.0:\n        shift -= 24.0\n    shifts.append(shift)\n\nxVals = np.arange(0,24,0.1)\nyVals = np.array([PRCFinder.exp_type0(x, 10.0) for x in xVals])\nplt.scatter(phases, shifts, color='black');\nplt.plot(xVals, yVals, color='black', ls='--');\n\nplt.title(\"Type 0 Human PRC\");\nplt.xlabel(\"Phase\") \nplt.ylabel(\"Phase Shift\")\n\n/var/folders/pq/2312g7dj24n0qmdb4frf4f9h0000gn/T/ipykernel_73537/235728984.py:27: RuntimeWarning: divide by zero encountered in double_scalars\n  val=(-1.57154+0.228932/(-1.0*b+x)-0.650632*x)*heaviside(b-x)+(9.66876+0.1321196/(-1.0*b+x)-0.463105*x)*heaviside(x-b)\n\n\nText(0, 0.5, 'Phase Shift')\n\n\n\n\n\n\nsource\n\n\nIntensityResponseCurveLight\n\n IntensityResponseCurveLight ()\n\nInitialize self. See help(type(self)) for accurate signature.\n\nsource\n\n\nDosageResponseCurve\n\n DosageResponseCurve ()\n\nInitialize self. See help(type(self)) for accurate signature."
  },
  {
    "objectID": "readers.html",
    "href": "readers.html",
    "title": "Readers",
    "section": "",
    "text": "wearable_schema = {\n    type: \"object\",\n    \"properties\": {\n            \"steps\": {\n                \"type\": \"array\",\n                \"items\": { \"type\": \"object\", \"properties\": { \n                    \"start\": { \"type\": \"number\" },\n                    \"end\": { \"type\": \"number\" },\n                    \"steps\": { \"type\": \"number\" } } },\n                \"minItems\": 1\n            },\n            \"wake\": {\n                \"type\": \"array\",\n                \"items\": { \"type\": \"object\", \"properties\": { \n                    \"start\": { \"type\": \"number\" },\n                    \"end\": { \"type\": \"number\" },\n                    \"wake\": { \"type\": \"number\" } } }\n            },\n            \"heartrate\": {\n                \"type\": \"array\",\n                \"items\": { \"type\": \"object\", \"properties\": { \n                    \"timestamp\": { \"type\": \"number\" },\n                    \"heartrate\": { \"type\": \"number\" },\n            } } },\n    },\n    \"required\": [\"steps\", \"wake\", \"heartrate\"]\n}\nDefine the WearableData class\nsource"
  },
  {
    "objectID": "readers.html#saving-and-loading-json",
    "href": "readers.html#saving-and-loading-json",
    "title": "Readers",
    "section": "Saving and Loading JSON",
    "text": "Saving and Loading JSON\nTo save a WearableData object to json we can use\nsample_data.to_json('test_export.json')\nand to load this back in we can do:\nwdata_loaded = WearableData.from_json('test_export.json')\n\nsource\n\nWearableData.plot_light_activity\n\n WearableData.plot_light_activity (show=True, vlines=None, *args,\n                                   **kwargs)"
  },
  {
    "objectID": "readers.html#actiwatch-readers",
    "href": "readers.html#actiwatch-readers",
    "title": "Readers",
    "section": "Actiwatch Readers",
    "text": "Actiwatch Readers\nExpected format for this follows the guidelines on predictdlmo. Should be a CSV file with the columns\nDate,Time,Activity,White Light,Sleep/Wake\n\nsource\n\nread_actiwatch\n\n read_actiwatch (filepath:str, MIN_LIGHT_THRESHOLD=5000, round_data=True,\n                 bin_minutes=6, dt_format:str=None,\n                 data_id:str='Actiwatch', subject_id:str='unknown-\n                 subject')\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfilepath\nstr\n\npath to actiwatch csv file\n\n\nMIN_LIGHT_THRESHOLD\nint\n5000\nused to trim off empty data at the beginning and end of the file, must reach this amount of light to be included. Turn this off can setting this to 0 or negative\n\n\nround_data\nbool\nTrue\nround the data to the nearest bin_minutes\n\n\nbin_minutes\nint\n6\nbin the data to this resolution in minutes, only used if round_data is true\n\n\ndt_format\nstr\nNone\nformat of the date time string, if None, will be inferred\n\n\ndata_id\nstr\nActiwatch\nname of the data source\n\n\nsubject_id\nstr\nunknown-subject\nsubject id to be used\n\n\nReturns\nWearableData\n\n\n\n\n\n\nlib_path = circadian.__path__[0]\nsample_actiwatch = read_actiwatch(filepath = lib_path + \"/sample_data/sample_actiwatch.csv\")\n\nsample_actiwatch._dataframe.head()\n\n\n\n\n\n  \n    \n      \n      datetime\n      time_total\n      activity\n      light_estimate\n      wake\n    \n  \n  \n    \n      0\n      2019-02-20 01:00:00\n      1.0\n      2720.0\n      345.435\n      1.0\n    \n    \n      1\n      2019-02-20 01:06:00\n      1.1\n      2162.0\n      924.555\n      1.0\n    \n    \n      2\n      2019-02-20 01:12:00\n      1.2\n      2341.0\n      1057.800\n      1.0\n    \n    \n      3\n      2019-02-20 01:18:00\n      1.3\n      2208.0\n      717.810\n      1.0\n    \n    \n      4\n      2019-02-20 01:24:00\n      1.4\n      2639.0\n      3.820\n      1.0\n    \n  \n\n\n\n\nWe can make some plots of the actiwatch data to help visualize it\n\nsample_actiwatch.plot_light_activity()\n\n\n\n\nCan also make use of the pandas plotting functions under the hood, by accessing the underlying dataframe.\n\nsample_actiwatch._dataframe.activity.plot();\n\n\n\n\nHere is an example of creating an actogram from the sample actiwatch data and adding in DLMO predictions from the Hannay single population model.\n\nacto = Actogram(sample_actiwatch.time_total, \n                sample_actiwatch.light_estimate, \n                second_zeit=sample_actiwatch.activity);"
  },
  {
    "objectID": "lights.html",
    "href": "lights.html",
    "title": "Lights",
    "section": "",
    "text": "source"
  },
  {
    "objectID": "lights.html#some-common-schedules",
    "href": "lights.html#some-common-schedules",
    "title": "Lights",
    "section": "Some Common Schedules",
    "text": "Some Common Schedules\n\nsource\n\nget_pulse\n\n get_pulse (t:float, t1:float, t2:float, repeat=False,\n            Intensity:float=150.0)\n\n\nsource\n\n\nmake_pulse\n\n make_pulse (t, tstart, tend, steep:float=30.0)\n\n\nLR_test = Light.RegularLight(lights_on=9.0, lights_off=1.0)\nLR_test.plot(0.0, 24.0);\n\nLR_test = Light.RegularLight(lights_on=8.0, lights_off=0.0)\nLR_test.plot(0.0, 24.0);\n\n\n\n\n\n\n\n\nlight_sum = Light(1.0, start_time=0.4, duration=1.0) + Light(10.0, start_time=3.0, duration=1.0)\nlight_sum.plot(0.0, 5.0, color='orange');\n\n\n\n\n\nLR = Light.RegularLight(lux=150.0, lights_on=10.0, lights_off=2.0)\n\ntimepoints = np.linspace(0, 48, 1000)\nlight_values = LR(timepoints, repeat_period=24.0)\n\nplt.fill(timepoints, light_values, color='orange', alpha=0.5);\nplt.xticks([0, 10, 26, 34], ['0:00','10:00', '02:00', '10:00']);\nplt.ylabel('Light Intensity (lux)');\nplt.xlabel('Time (hours)');\n\n\n\n\n\nlf = Light(lambda t: 150.0, start_time=10.0, duration=16.0)\nlf.plot(start_time=0.0, end_time=48.0, color='orange');\n\n\n\n\n\ntest_eq(lf(np.array([10.0])), 150.0)\ntest_eq(lf(np.array([2.0])), 0.0)\ntest_eq(lf(np.array([34.0]), repeat_period=24.0), 150.0) # should repeat every 24 hours\n\n\n# can pass in a list and get an numpy array back\ntest_eq(type(lf([2.0])), np.ndarray)\n\n\nfrom circadian.plots import Actogram \n\nsw_light = Light.ShiftWorkLight(dayson=5, daysoff=2)\nts = np.arange(0, 24*7*6, 0.10)\nlight_values = sw_light(ts, repeat_period=24*7)\n\nActogram(ts, light_vals=light_values, smooth=False);\n\n\n\n\n\nslam_shift = Light.SlamShift(shift=8.0,\n                             before_days=10, \n                             after_days=40)\nts = np.arange(0, 24*40, 0.10)\nlight_values = slam_shift(ts)\n\nActogram(ts, light_vals=light_values, smooth=False);\n\n\n\n\n\nsocial_jl = Light.SocialJetlag()\nts = np.arange(0, 24*40, 0.10)\nlight_values = social_jl(ts, repeat_period=24*7)\n\nActogram(ts, light_vals=light_values, smooth=False);\nplt.title(\"Social Jetlag Light Schedule\");"
  },
  {
    "objectID": "cli.html",
    "href": "cli.html",
    "title": "CLI",
    "section": "",
    "text": "!acto --help\n\nusage: acto [-h] [-j JSON] [-c CSV] [-sm SLEEPMODEL] [-d] [-cbt] [--sleep]\n            [-t THRESHOLD] [-m MULTIPLIER] [-p PERIOD] [-r] [--scatter]\n            [-t1 T1] [-t2 T2] [-s SIGMA]\n\nMake an actogram\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -j JSON, --json JSON  Specify a json file with the data\n  -c CSV, --csv CSV     Specify a directory with csv data in it\n  -sm SLEEPMODEL, --sleepmodel SLEEPMODEL\n                        Machine learning pytorch model for steps and heartrate\n                        to wake prediction\n  -d, --dlmo            Integrate the model and plot dlmo times\n  -cbt, --cbt           Integrate the model and plot core body temperature\n                        times\n  --sleep               Add sleep midpoints\n  -t THRESHOLD, --threshold THRESHOLD\n                        Threshold for displaying as light on the actogram\n  -m MULTIPLIER, --multiplier MULTIPLIER\n                        Steps to light multiplier\n  -p PERIOD, --period PERIOD\n                        Set the SPM period\n  -r, --raw             Plot the raw steps and heartrate data\n  --scatter             Plot the raw steps and heartrate data\n  -t1 T1, --t1 T1       Trim data before this time, in days\n  -t2 T2, --t2 T2       Trim data after this time, in days\n  -s SIGMA, --sigma SIGMA\n                        Smooth the light(steps) data\n\n\n\nsource\n\nmain_acto\n\n main_acto ()\n\n\nsource\n\n\nmain_esri\n\n main_esri ()\n\n\n!esri --help\n\nusage: esri [-h] [-a] [-j JSON] [-c CSV] [-s SIGMA] [-t1 T1] [-t2 T2]\n            [-sm SLEEPMODEL] [-t THRESHOLD] [-o OUTFILE] [-np]\n\nCompute the Entrainment Signal Regularity Index for a data set\n\noptional arguments:\n  -h, --help            show this help message and exit\n  -a, --actogram\n  -j JSON, --json JSON  Specify a json file with the data\n  -c CSV, --csv CSV     Specify a directory with csv data in it\n  -s SIGMA, --sigma SIGMA\n                        Smooth the light(steps) data\n  -t1 T1, --t1 T1       Trim data before this time, in days\n  -t2 T2, --t2 T2       Trim data after this time, in days\n  -sm SLEEPMODEL, --sleepmodel SLEEPMODEL\n                        Machine learning pytorch model for steps and heartrate\n                        to wake prediction\n  -t THRESHOLD, --threshold THRESHOLD\n                        Threshold for displaying as light on the actogram\n  -o OUTFILE, --outfile OUTFILE\n                        Path to the outfile\n  -np, --noplot         Use this to suppress the plot"
  },
  {
    "objectID": "sleep.html",
    "href": "sleep.html",
    "title": "Sleep",
    "section": "",
    "text": "The below model uses a simple two process model for sleep to take a circadian trajectory and create a prediction of the homeostat (sleep hunger) which increases during wake and decreases during sleep. The steps parameter can be used to force wake, values of that array that are above the threshold will force a wake state.\n\nsource\n\n\n\n TwoProcessModel (steps_wake_threshold:float=10.0)\n\nInitialize self. See help(type(self)) for accurate signature.\n\nmodel = Hannay19()\nts = np.arange(0, 24*30, 0.10)\nlight = Light.SlamShift(after_days=30)\nlight_est = light(ts) \nic = model.default_initial_conditions\ntrajectory = model(ts, light_est, ic)\nsleep_model = TwoProcessModel()\nhomeostat = sleep_model(trajectory.ts, trajectory.states[1,:], light_est)\n\n# Where the homeostat is increasing, we are awake where decreasing we are asleep\nwake_predicted = np.where(np.diff(homeostat.states[0,:],prepend=0.0) > 0.0, 1.0, 0.0)\nax = plt.gca()\nActogram(ts, light_vals=light_est, threshold=10.0, color='black', alpha=0.5, smooth=False, ax=ax)\nActogram(ts, light_vals=wake_predicted, threshold=0.50, color='green', alpha=0.1, smooth=False, ax=ax);\nax.set_title('Sleep During a Slam Shift: Twp Process Model');\n\n\n\n\n\nsource\n\n\n\n\n sleep_midpoint (timetotal:numpy.ndarray, Wake:numpy.ndarray,\n                 durations=True)\n\nGiven a wearable data frame with a Wake column which takes the values 0, 1, missing this routine will create a sleep phase column which is based on constant phase accumulation between sleep midpoints.\nThe sleep midpoints are found using the criteria than they the median time where\n\nsource\n\n\n\n\n cluster_sleep_periods_scipy (wake_data:numpy.ndarray, epsilon:float,\n                              makeplot:bool=False,\n                              max_sleep_clusters=None,\n                              min_sleep_clusters=None)\n\nGiven a binary vector wake_data which gives a prediction for the sleep/wake\nstatus and a regularization penalty ε this function will create smoothed sleep-wake periods. This helps as preprocessing to remove erroneous short sleep periods (and wake) which may mess up calculations like the sleep midpoint for the day\ncluster_sleep_periods(wake_data : np.ndarray, epsilon: float, makeplot: bool=False):"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Circadian",
    "section": "",
    "text": "pip install circadian"
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Circadian",
    "section": "Quick start",
    "text": "Quick start\nThe below shows how to simulate a shift worker schedule for three models and make an actogram plot\n\nfrom circadian.plots import Actogram\nfrom circadian.models import *\nfrom circadian.lights import Light\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndays_night = 3\ndays_day = 2\nslam_shift = Light.ShiftWorkLight(lux = 300.0, \n                                  dayson=days_night, \n                                  daysoff=days_day)\nts = np.arange(0, 24*30,0.10)\nlight_values = slam_shift(ts, repeat_period=24*(days_night+days_day))\n\nf_model = Forger99Model()\nspm_model = Hannay19()\ntpm_model = Hannay19TP()\nkj_model = KronauerJewett()\ninitial_conditions_forger = f_model.initial_conditions_loop(ts, light_est=light_values, num_loops=1)\ninitial_conditions_kj = kj_model.initial_conditions_loop(ts, light_est=light_values, num_loops=1)\ninitial_conditions_spm = spm_model.initial_conditions_loop(ts, light_est=light_values, num_loops=1)\ninitial_conditions_tpm = tpm_model.initial_conditions_loop(ts, light_est=light_values, num_loops=1)\n\nIntegrate the models using a explicit RK4 scheme\n\ntrajectory = f_model(ts=ts, light_est=light_values, state = initial_conditions_forger)\ntrajectory_kj = kj_model(ts=ts, light_est=light_values, state = initial_conditions_kj)\ntrajectory_spm = spm_model(ts=ts, light_est=light_values, state = initial_conditions_spm)\ntrajectory_tpm = tpm_model(ts=ts, light_est=light_values, state = initial_conditions_tpm)\n\nFind the dlmos (Dim Light Melatonin Onset) a experimental measurement of circadian phase\n\ndlmo_f = f_model.dlmos(trajectory)\ndlmo_kj = kj_model.dlmos(trajectory)\ndlmo_spm = spm_model.dlmos(trajectory_spm)\ndlmo_tpm = tpm_model.dlmos(trajectory_tpm)\n\nNow let’s make an actogram plot of the light schedule with the DLMOs shown for the simulated shiftworker\n\nacto = Actogram(ts, light_vals=light_values, opacity=1.0, smooth=False)\nacto.plot_phasemarker(dlmo_f, color='blue', label= \"DLMO Forger99\")\nacto.plot_phasemarker(dlmo_spm, color='darkgreen', label = \"DLMO SPM\")\nacto.plot_phasemarker(dlmo_tpm, color='red', label = \"DLMO TPM\" )\nacto.plot_phasemarker(dlmo_kj, color='purple', label = \"DLMO TPM\" )\nplt.title(\"Actogram for a Simulated Shift Worker\")\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "metrics.html",
    "href": "metrics.html",
    "title": "Metrics",
    "section": "",
    "text": "source\n\nesri\n\n esri (awObj:circadian.readers.WearableData, gamma:float=0.0,\n       multiplier:float=1.0, num_days:float=4.5)\n\n\nsource\n\n\nesri_trajectory\n\n esri_trajectory (awObj:circadian.readers.WearableData, gamma:float=0.0,\n                  multiplier:float=1.0, num_days:float=4.5)"
  },
  {
    "objectID": "phasetools.html",
    "href": "phasetools.html",
    "title": "Phase Tools",
    "section": "",
    "text": "The simplest and one of the most popular techniques is so-called cosinor analysis, which is a very fancy term for doing a linear regression on cosine transformed data.\n\\[ y = A \\cos(x + \\beta) \\]\nor in the form that I prefer:\n\\[q(t,\\phi) = a_1 \\sin(\\omega t) + a_2 \\cos(\\omega t) \\]\nIn cosinor analysis the \\(\\omega\\) term (the frequency) is taken as a known quantity and the \\(a_{1,2}\\) terms are fit to minimize the least square error.\nThen the phase \\(\\phi\\) is given by \\(\\arg(a_2 + i a_1)\\)\n\ndef f_signal_cosinor(t: np.array, phi: float, tau: float = 100.0) -> np.array:\n    return np.cos(2 * np.pi/tau * t - phi)\n\nphi_true = 2.0\nx_sample = np.arange(0, 200, 5)\ny_sample = f_signal_cosinor(x_sample, phi_true) \ny_sample_noisy = y_sample + np.random.normal(0, 0.5, x_sample.shape)\n\nplt.scatter(x_sample,y_sample_noisy, color='k', s=20, label='Noisy Measurements')\nplt.plot(x_sample, y_sample, ls = '--', color = 'k', label = 'True Signal');\nplt.legend()\nplt.title('Cosinor Example Signal with Noise');\n\n\n\n\nExample Cosinor Data\n\n\n\n\nIt is easy enough to use built in regression functions to find \\(a_{1,2}\\) but we can easily solve this ourselves. First, lets define the terms \\(y\\) is the signal, \\(t\\) is the sampling times the same length as \\(y\\). The matrix \\(S\\) is formed by taking the sin/cos of the time vectors and placing them in the columns \\(S = [sin(\\omega t); cos(\\omega t)]\\). Thus, we can write our system as:\n\\[ S a = y \\]\nwhere \\(a = [a_1, a_2]\\) are the two coefficients we want to solve for. This regression is especially easy to compute in this case because the matrix \\(S\\) has the property that the columns are orthogonal (S is a orthogonal matrix). This means that \\(S^T S = I\\), and we can solve the system with one matrix transpose multiplication.\n\\[\\begin{align}\nSa = y \\\\\nS^T S a = S^T y, S^T S = I \\\\\na = S^T y\n\\end{align}\\]\nSince \\(S^T\\) only has two columns we can write the matrix-vector product out for each component:\n\\[\\begin{align}\na_1 = \\frac{ \\sin(\\omega t) \\cdot y}  { || \\sin(\\omega t) ||^2 } \\\\\na_2 = \\frac { \\cos(\\omega t) \\cdot y } { || \\cos(\\omega t) ||^2 }\n\\end{align}\\] Here is a quick implementation in python.\n\nsource\n\n\n\n cosinor (t:<built-infunctionarray>, y:<built-infunctionarray>, tau:float)\n\n\n\n\n\nType\nDetails\n\n\n\n\nt\narray\ntime vector\n\n\ny\narray\nsignal vector\n\n\ntau\nfloat\nperiod of cosinor analysis\n\n\nReturns\nfloat\nphase estimate\n\n\n\n\nsource\n\n\n\n\n cosinor_phase (a:<built-infunctionarray>)\n\n\na_coeffs = cosinor(x_sample, y_sample_noisy, 100.0)\nprint(f\"Recovered Cosinor Parameters {a_coeffs[0]:.4f} sin(omega t) + {a_coeffs[1]:.4f} cos(omega t)\")\nprint(f\"Phase Estimate: {cosinor_phase(a_coeffs):.4f} versus the true phase: {phi_true:.4f}\")\n\n\nplt.scatter(x_sample,y_sample_noisy, color='k', s=20, label='Noisy Measurements')\nplt.plot(x_sample, y_sample, ls = '--', color = 'k', label = 'True Signal')\nplt.plot(x_sample, a_coeffs[0]*np.sin(2*np.pi/100.0 *x_sample) + a_coeffs[1]*np.cos(2*np.pi/100.0 *x_sample), ls = '--', color = 'r', label = 'Cosinor Fit');\nplt.legend()\nplt.title('Cosinor Example Signal with Noise');\n\nRecovered Cosinor Parameters 0.9207 sin(omega t) + -0.3776 cos(omega t)\nPhase Estimate: 1.9600 versus the true phase: 2.0000\n\n\n\n\n\n\n\n\nOne of the main challenges with the cosinor method is that it assumes that the data is continuous. This is not always the case. For example, if you are measuring a signal at a fixed time interval, but the signal is not present at all times, then you will have gaps in your data.\nThe GOALs algorithm (citation) is a modification of the cosinor method that allows for gaps in the data.\n\nsource\n\n\n\n cosinor_goals (t, y, tau:float)\n\n\nphi_true = 2.0\nx_sample = np.hstack((np.arange(0, 20, 1), np.arange(40, 60, 1)))\ny_sample = f_signal_cosinor(x_sample, phi_true) \ny_sample_noisy = y_sample + np.random.normal(0, 0.5, x_sample.shape)\n\na_coeffs = cosinor_goals(x_sample, y_sample_noisy, 100.0)\nprint(f\"Recovered GOALS Cosinor Parameters {a_coeffs[0]:.4f} sin(omega t) + {a_coeffs[1]:.4f} cos(omega t)\")\nprint(f\"GOALS Phase Estimate: {cosinor_phase(a_coeffs):.4f} versus the true phase: {phi_true:.4f}\")\n\n\na_coeffs_plain = cosinor(x_sample, y_sample_noisy, 100.0)\nprint(f\"Recovered Cosinor Parameters {a_coeffs_plain[0]:.4f} sin(omega t) + {a_coeffs_plain[1]:.4f} cos(omega t)\")\nprint(f\"Regular Cosinor Phase Estimate: {cosinor_phase(a_coeffs_plain):.4f} versus the true phase: {phi_true:.4f}\")\n\nx_fill = np.arange(0, 100, 1)\ny_fill = f_signal_cosinor(x_fill, phi_true)\nplt.scatter(x_sample,y_sample_noisy, color='k', s=20, label='Noisy Measurements')\nplt.plot(x_fill, y_fill, ls = '--', color = 'k', label = 'True Signal')\nplt.plot(x_fill, a_coeffs[0]*np.sin(2*np.pi/100.0 *x_fill) + a_coeffs[1]*np.cos(2*np.pi/100.0 *x_fill), ls = '--', color = 'r', label = 'GOALs Cosinor Fit');\nplt.plot(x_fill, a_coeffs_plain[0]*np.sin(2*np.pi/100.0 *x_fill) + a_coeffs_plain[1]*np.cos(2*np.pi/100.0 *x_fill), ls = '--', color = 'b', label = 'Cosinor Fit');\nplt.legend()\nplt.title('Cosinor (GOALS) Example Signal with Noise');\n\nRecovered GOALS Cosinor Parameters 0.3053 sin(omega t) + -0.7676 cos(omega t)\nGOALS Phase Estimate: 2.7630 versus the true phase: 2.0000\nRecovered Cosinor Parameters 0.5447 sin(omega t) + -0.5027 cos(omega t)\nRegular Cosinor Phase Estimate: 2.3162 versus the true phase: 2.0000"
  },
  {
    "objectID": "plots.html",
    "href": "plots.html",
    "title": "Plots",
    "section": "",
    "text": "Actograms help display periodic trends in data.\n\n\n\n\n\n\nNote\n\n\n\nI prefer my actograms to show low values as black and high values as white. The convention in circadian science (for some reason) is the reverse. This can easily be switched in plot calls if you want to do things the wrong way.\n\n\n\nsource\n\n\n\n Actogram (time_total:numpy.ndarray, light_vals:numpy.ndarray,\n           second_zeit:numpy.ndarray=None, ax=None, threshold=10.0,\n           threshold2=None, opacity:float=1.0, color:str='black',\n           smooth=True, sigma=[2.0, 2.0], *args, **kwargs)\n\nCreate an Actogram visualisation of the data\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntime_total\nndarray\n\ntime in hours\n\n\nlight_vals\nndarray\n\nlight values or proxy should be the same length as time_total\n\n\nsecond_zeit\nndarray\nNone\noptional second zeitgeber to show on the right side\n\n\nax\nNoneType\nNone\nAxis to plot on, if None a new figure is created\n\n\nthreshold\nfloat\n10.0\nthreshold for light on/off\n\n\nthreshold2\nNoneType\nNone\nthreshold for light on/off for second zeitgeber\n\n\nopacity\nfloat\n1.0\nopacity of the light on/off rectangles\n\n\ncolor\nstr\nblack\ncolor of the light on/off rectangles, for the below threshold values\n\n\nsmooth\nbool\nTrue\nwhether to apply a gaussian filter to the light values to smooth it, useful for wearable data\n\n\nsigma\nlist\n[2.0, 2.0]\nsigma for the gaussian filter\n\n\nargs\n\n\n\n\n\nkwargs\n\n\n\n\n\n\n\nslam_shift = Light.SlamShift() \nts = np.arange(0, 20*24.0, 0.10)\nlight_values = slam_shift(ts) \n\nact = Actogram(ts, light_vals=light_values, smooth=False)\nspm = Hannay19()\n\ntrajectory = spm(ts, light_values, np.array([1.0, np.pi, 0.0]))\ndlmo = spm.dlmos(trajectory=trajectory)\n\nact.plot_phasemarker(dlmo, color='blue')\nplt.show()\n\n\n\n\n\nsource\n\n\n\n\n plot_mae (dlmo_actual:numpy.ndarray, dlmo_pred:numpy.ndarray,\n           norm_to:float=None, ax=None, *args, **kwargs)\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ndlmo_actual\nndarray\n\nexpected to be in hours\n\n\ndlmo_pred\nndarray\n\npredicted to be in hours\n\n\nnorm_to\nfloat\nNone\n\n\n\nax\nNoneType\nNone\n\n\n\nargs\n\n\n\n\n\nkwargs\n\n\n\n\n\n\n\ndlmo_experimental = np.linspace(-12, 12., 30) \ndlmo_predicted = dlmo_experimental + np.random.normal(0, 2, len(dlmo_experimental))\n\nplot_mae(dlmo_experimental, dlmo_predicted)\n\nThe MAE is: 2.641398741517547\nWithin one hour 11/30\n[-21.01173639  -0.12531967   1.40312246  -2.31314249  20.38979752\n   0.56289487  -3.49731123   0.98514845  -0.91249928  -0.89321195\n  -2.13931562   0.1464234   -0.6518082    1.7019575    1.80022305\n   1.42892014  -1.51779066   1.4803608   -1.72819525  -3.36460062\n  -0.04373978  -1.62496309  -0.37156094  -1.81570189  -0.10431195\n  -0.83907585  -1.61293433  -1.54634351  -1.67393395  -1.55561742]\n\n\n\n\n\n\nsource\n\n\n\n\n plot_torus (phase1:numpy.ndarray, phase2:numpy.ndarray,\n             scaled_by:float=None, ax=None, *args, **kwargs)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nphase1\nndarray\n\narray of phases\n\n\nphase2\nndarray\n\narray of phases, assumed to be the same length as phase1\n\n\nscaled_by\nfloat\nNone\nshould the phases be wrapped, this just applies an fmod to the phases\n\n\nax\nNoneType\nNone\naxis to plot on, if None, a new figure is created\n\n\nargs\n\n\n\n\n\nkwargs\n\n\n\n\n\nReturns\nAxes\n\npassed to the scatter plotpassed to the scatter plot\n\n\n\nHere is an example of the torus plot, which allows one to visualize the relationsjip between two phases.\n\nphi1 = 12.0 + 5.0*np.random.randn(100) \nphi2 = phi1 + 5.0*np.random.randn(100)\n\nplot_torus(phi1, phi2, scaled_by=24.0, color='darkgreen')\nplt.title(\"Example torus plot\")\nplt.xlabel(\"$\\phi_1$\") \nplt.ylabel(\"$\\phi_2$\");\n\n\n\n\nExample of an actogram\n\nsource\n\n\n\n\n Stroboscopic (ax:matplotlib.axes._axes.Axes, ts:numpy.ndarray,\n               amplitude:numpy.ndarray, phase:numpy.ndarray,\n               period:float=24.0, *args:tuple, **kwargs:dict)\n\nThis class can be used to make a stroboscopic plot of the entrainment of an oscillator to a sudden shift in schedule\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nax\nAxes\n\nThe axes to plot on\n\n\nts\nndarray\n\nThe time series of the model\n\n\namplitude\nndarray\n\nThe amplitude of the model, assumed to be the same length as ts\n\n\nphase\nndarray\n\nThe phase of the model, assumed to be the same length as ts\n\n\nperiod\nfloat\n24.0\nThe time period between stroboscopic arrows\n\n\nargs\ntuple\n\n\n\n\nkwargs\ndict\n\n\n\n\n\nThis is how you can visualize entrainment using a Stroboscopic plot of a trajectory\n\nslam_shift = Light.SlamShift(shift=12.0, lux = 500.0, before_days = 2, after_days=30) \nts = np.arange(0.0, 15*24.0, 0.10)\nlight_values = slam_shift(ts)\n# Run this for a range of period parameters \nbatch_dim = 50\nhmodel = Hannay19({ 'tau': np.linspace(23.5,24.5,batch_dim) }) \n\ninitial_state = np.array([1.0, np.pi, 0.0]) + np.zeros((batch_dim, 3))\ntrajectory = hmodel(ts=ts, light_est=light_values, state=initial_state)\nax = plt.gca()\ncmap = plt.get_cmap('jet')\nfor idx in range(trajectory.batch_size):\n    Stroboscopic(ax, \n                ts, \n                trajectory.states[idx, 0, :], \n                trajectory.states[idx, 1, :], \n                period=24.0, \n                lw=0.50,\n                color=cmap(idx/batch_dim));\nplt.title(\"Stroboscopic plot of the Hannay et al. 2019 model\");\n\n\n\n\n\nsource\n\n\n\n\n plot_actogram (ax:matplotlib.axes._axes.Axes, zeitgeber:numpy.ndarray,\n                num_day:int=240, cmap:matplotlib.colors.Colormap=<matplotl\n                ib.colors.LinearSegmentedColormap object at\n                0x7f1a39fb26d0>, label_days:int=7, *args, **kwargs)\n\nMake an actogram plot with color\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nax\nAxes\n\nplot axes\n\n\nzeitgeber\nndarray\n\nthe zeitgeber to display\n\n\nnum_day\nint\n240\nnumber of points per day\n\n\ncmap\nColormap\n<matplotlib.colors.LinearSegmentedColormap object at 0x7f1a39fb26d0>\nthe colormap to use\n\n\nlabel_days\nint\n7\nthe number of days between labels\n\n\nargs\n\n\n\n\n\nkwargs\n\n\n\n\n\nReturns\nAxes\n\npassed to imshowpassed to imshow\n\n\n\n\nslam_shift = Light.ShiftWorkLight() \nts = np.arange(0, 30*24.0, 0.10)\nlight_values = slam_shift(ts, repeat_period=24.0*5) + np.random.randn(len(ts)) * 1.0\n\nfig, ax = plt.subplots(1,2, sharey='row')\nact = plot_actogram(ax[0], zeitgeber=light_values, cmap='viridis')\nact = plot_actogram(ax[1], zeitgeber=light_values)\n\nfig.subplots_adjust(wspace=0, hspace=0)\n\n\n\n\n\nsource\n\n\n\n\n plot_phasetimes (ax:matplotlib.axes._axes.Axes, times:numpy.ndarray,\n                  phases:numpy.ndarray, error:numpy.ndarray=None,\n                  alpha_error=0.3, alpha=1.0, *args, **kwargs)\n\nThis method takes observations of the phase and times (same length arrays) and adds them to the actogram.\nplot_phasetimes(self, times: np.ndarray, phases: np.ndarray, *args, **kwargs)\n\n# import circadian\n# from circadian.readers import read_standard_json\n# cpath = circadian.__path__[0]\n# wdata = read_standard_json(cpath + '/sample_data/sample_data.json')\n# fig, ax = plt.subplots(1,1, sharey='row')\n# plot_actogram(ax, zeitgeber=np.log(wdata.steps+1.0), cmap='jet', label_days=21)\n# ax.set_ylabel('Days')\n# ax.set_xlabel(\"ZT\");\n# -6.0 is to shift the time to the correct timezone from the UTC timezone of the data"
  },
  {
    "objectID": "utils.html",
    "href": "utils.html",
    "title": "Utilities",
    "section": "",
    "text": "source"
  },
  {
    "objectID": "utils.html#circular-stats",
    "href": "utils.html#circular-stats",
    "title": "Utilities",
    "section": "Circular Stats",
    "text": "Circular Stats\n\nsource\n\ncircular_scatter\n\n circular_scatter (ax, angles, clock_times=False, radius=1.0,\n                   color='blue')\n\nAdds a polar scatter plot of clock times to an axes with polar axis i.e. ax = plt.subplot(111, polar=True) Will also plot the circular mean angle and the phase coherence\n\nsource\n\n\ncircular_av_clock\n\n circular_av_clock (series)\n\nFind the average time given a list of clock times\n\nsource\n\n\nsubtract_clock_times\n\n subtract_clock_times (c1, c2)\n\nFind the hour differences between two clock times new\n\nsource\n\n\nangle_difference\n\n angle_difference (c1, c2)\n\nFind the angle between two angles given in radians angle_difference(c1, c2) c1-c2\n\nsource\n\n\nphase_coherence_clock\n\n phase_coherence_clock (series)\n\n\nsource\n\n\nphase_coherence\n\n phase_coherence (series)\n\n\nsource\n\n\ncircular_mean\n\n circular_mean (series)"
  },
  {
    "objectID": "utils.html#data-related-utils",
    "href": "utils.html#data-related-utils",
    "title": "Utilities",
    "section": "Data related utils",
    "text": "Data related utils\n\nsource\n\nsplit_drop_data\n\n split_drop_data (date_time, ts, steps, hr, wake, break_threshold=96.0,\n                  min_length:float=30.0)\n\nUsed to split long JSON into contin data steaks of at least X=30 days.\nUses that missing data will be zeros for steps and hr and 0.5 for the wake data.\nmin_length is in days\n\nsource\n\n\nsplit_missing_data\n\n split_missing_data (date_time, ts, y, hr=None, break_threshold=96.0)\n\n\nsource\n\n\ntimezone_mapper\n\n timezone_mapper (dt_object:<module'datetime'from'/opt/hostedtoolcache/Pyt\n                  hon/3.9.16/x64/lib/python3.9/datetime.py'>,\n                  timezone:str='America/Detroit')\n\nTake in local time as datetime object and give back UTC with day lights savings accounted for as a timestamp\n\nsource\n\n\ntimes_to_angle\n\n times_to_angle (time_vector:numpy.ndarray)\n\nTake an array of times and return R, psi giving the mean angle (psi) and amplitude (R)\n\nsource\n\n\nNpEncoder\n\n NpEncoder (skipkeys=False, ensure_ascii=True, check_circular=True,\n            allow_nan=True, sort_keys=False, indent=None, separators=None,\n            default=None)\n\nExtensible JSON http://json.org encoder for Python data structures.\nSupports the following objects and types by default:\n\n\n\n\n\n\n\nPython\nJSON\n\n\n\n\ndict\nobject\n\n\nlist, tuple\narray\n\n\nstr\nstring\n\n\nint, float\nnumber\n\n\nTrue\ntrue\n\n\nFalse\nfalse\n\n\nNone\nnull\n\n\n\nTo extend this to recognize other objects, subclass and implement a .default() method with another method that returns a serializable object for o if possible, otherwise it should call the superclass implementation (to raise TypeError).\nThis function can be used to redact the dates from a json file, this is to protect the user privacy. The start of the timestamps will be set back to the unix epoch time.\n\nsource\n\n\nredact_dates\n\n redact_dates (infile:str, outfile:str, gzip_opt:bool=False)\n\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ninfile\nstr\n\nthe input file in json format\n\n\noutfile\nstr\n\nthe output file in json format with dates redacted, for user privacy\n\n\ngzip_opt\nbool\nFalse\nif the input file is gzipped, if the extension is .gz, this is set to True\n\n\nReturns\nNone"
  },
  {
    "objectID": "models.html",
    "href": "models.html",
    "title": "Models",
    "section": "",
    "text": "Lets first define a helper class to store the solutions for differential equation models.\nsource"
  },
  {
    "objectID": "models.html#abstract-base-class-circadian-model",
    "href": "models.html#abstract-base-class-circadian-model",
    "title": "Models",
    "section": "Abstract Base Class: Circadian Model",
    "text": "Abstract Base Class: Circadian Model\n\nsource\n\nCircadianModel\n\n CircadianModel (params:dict=None)\n\nAbstract base class for circadian models, defines the interface for all models\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nparams\ndict\nNone\ndictionary of parameters for the model, if None then the default parameters are used\n\n\n\nEach of the models can be initialized by using a dictionary of parameter values, although they have default parameter values taken from the publications. The dictionary passed can overwrite just one of the parameters and leave the remaining as the default values.\n\nsource\n\n\nCircadianModel.__init__\n\n CircadianModel.__init__ (params:dict=None)\n\nCreates a new instance of the model\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nparams\ndict\nNone\ndictionary of parameters for the model, if None then the default parameters are used\n\n\n\nThe parameters for the model can be returned using\n\nsource\n\n\nCircadianModel.get_parameters\n\n CircadianModel.get_parameters ()\n\nReturns the parameters for the model\n\nsource\n\n\nCircadianModel.__call__\n\n CircadianModel.__call__ (ts:numpy.ndarray, light_est:numpy.ndarray,\n                          state:numpy.ndarray, *args, **kwargs)\n\nWrapper to integrate_model, can just call the model object directly\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nts\nndarray\nArray of time points, also determines step size of RK4 solver\n\n\nlight_est\nndarray\nArray of light estimates, should be the same length as ts\n\n\nstate\nndarray\nInitial state of the model\n\n\nargs\n\n\n\n\nkwargs\n\n\n\n\n\n\nsource\n\n\nCircadianModel.integrate_model\n\n CircadianModel.integrate_model (ts:numpy.ndarray,\n                                 light_est:numpy.ndarray,\n                                 state:numpy.ndarray)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\nts\nndarray\nArray of time points, also determines step size of RK4 solver\n\n\nlight_est\nndarray\nArray of light estimates, should be the same length as ts\n\n\nstate\nndarray\nInitial state of the model\n\n\nReturns\nDynamicalTrajectory\n\n\n\n\n\nsource\n\n\nCircadianModel.dlmos\n\n CircadianModel.dlmos (trajectory:__main__.DynamicalTrajectory)\n\nFinds the Dim Light Melatonin Onset (DLMO) markers for the model along a trajectory\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntrajectory\nDynamicalTrajectory\nsolution from integrate_model\n\n\nReturns\nndarray\narray of times when the dlmo occurs for the model\n\n\n\n\nsource\n\n\nCircadianModel.cbt\n\n CircadianModel.cbt (trajectory:__main__.DynamicalTrajectory)\n\nFinds the core body temperature minumum markers for the model along a trajectory\n\n\n\n\nType\nDetails\n\n\n\n\ntrajectory\nDynamicalTrajectory\nsolution from integrate_model\n\n\nReturns\nndarray\narray of times when the cbt occurs\n\n\n\n\nsource\n\n\nCircadianModel.observer\n\n CircadianModel.observer (trajectory:numpy.ndarray, observer_func:<built-\n                          infunctioncallable>)\n\nDefines a generic observer for the model, this will return the times when the observer_func changes sign\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ntrajectory\nndarray\nsolution from integrate_model\n\n\nobserver_func\ncallable\nfunction that takes the state of the model and returns a scalar will be triggered when the sign of the function changes\n\n\nReturns\narray\nthis will return the times when the observer func changes signs\n\n\n\n\nsource\n\n\nCircadianModel.amplitude\n\n CircadianModel.amplitude (state:numpy.ndarray)\n\nGives the amplitude of the model at a given state\n\n\n\n\nType\nDetails\n\n\n\n\nstate\nndarray\ndynamic state of the model\n\n\nReturns\nfloat\n\n\n\n\n\nsource\n\n\nCircadianModel.phase\n\n CircadianModel.phase (state:numpy.ndarray)\n\nGives the phase of the model at a given state\n\n\n\n\nType\nDetails\n\n\n\n\nstate\nndarray\ndynamic state of the model\n\n\nReturns\nfloat\n\n\n\n\n\nsource\n\n\nCircadianModel.default_initial_conditions\n\n CircadianModel.default_initial_conditions ()\n\nDefines some default initial conditions for the model\n\nsource\n\n\nCircadianModel.initial_conditions_loop\n\n CircadianModel.initial_conditions_loop (ts:numpy.ndarray,\n                                         light_est:numpy.ndarray,\n                                         num_loops:int=30)\n\nEstimate the starting values by looping the given light_estimate, commonly used for to estimate the initial conditions assumes the individual lives the same schedule repeatedly\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nts\nndarray\n\nArray of time points, also determines step size of RK4 solver\n\n\nlight_est\nndarray\n\nArray of light estimates, should be the same length as ts\n\n\nnum_loops\nint\n30\n\n\n\nReturns\nndarray"
  },
  {
    "objectID": "models.html#forger99",
    "href": "models.html#forger99",
    "title": "Models",
    "section": "Forger99",
    "text": "Forger99\nThis model is taken from (Forger, Jewett, and Kronauer 1999) which defines a simplification of previous iterations of the van der Pol based oscillator models published in the 1990s. It is one of the most popular models in the circadian literature. This implementation uses the parameters taken from (Serkh and Forger 2014) rather than the parameters from the original paper.\nThe model states are defined by three dynamic variables \\((x, x_c, n)\\). These states are related to circadian rhythms by defining the core body temperature minimum (a biomarker for circadian state) to be the minimum of the \\(x\\) variable.\n\nsource\n\nForger99Model\n\n Forger99Model (params:dict=None)\n\nImplementation of the Forger 1999 model\n\nsource\n\n\nForger99Model.derv\n\n Forger99Model.derv (y:numpy.ndarray, light:float)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ny\nndarray\ndynamical state (x, xc, n)\n\n\nlight\nfloat\nlight value in lux\n\n\nReturns\nndarray\nThis defines the ode system for the forger 99 model\n\n\n\nHere is how we can define the model and run a simulation\n\nts = np.arange(0, 24*7, 0.1)\nlight_values = np.zeros_like(ts) # simulate in darkness\nfmodel = Forger99Model()\n\ntrajectory = fmodel(ts, light_values, state=np.array([0.10,-0.10,0.0]))\n\nplt.plot(trajectory.states[0,:], trajectory.states[1,:])\nplt.title(\"Phase plane plot of Forger99 Model in darkness\")\nplt.xlabel(\"x\")\nplt.ylabel(\"$x_c$\");\n\n\n\n\nWe can also make a time plot of the dynamics\n\n# Integrate observer for the Forger 99 model\n\nplt.plot(trajectory.ts, trajectory.states[0,:], label=\"x\")\nplt.plot(trajectory.ts, trajectory.states[1,:], label=\"$x_c$\")\nplt.xlabel(\"Time (hours)\")\nplt.ylabel(\"State\")\nplt.title(\"Forger 99 model in darkness\")\nplt.legend()\nplt.show();\n\n\n\n\nWe can also run a the model for a whole collection of initial conditions in one pass by just adding a batch dimension to the initial state. Here we show how to run the Forger model for 100 random initial conditions centered on an initial estimate.\n\nts = np.arange(0, 24*7, 0.1)\nlight_values = np.zeros_like(ts) \nfmodel = Forger99Model()\n\ninitial_conditions_batch = np.array([0.10,-0.10,0.0]) + np.random.normal(0, 0.1, (100,3))\n\ntrajectory = fmodel.integrate_model(ts, \n                             light_values, \n                             state=initial_conditions_batch)\n\nfor i in range(100):\n    plt.plot(trajectory.ts, trajectory.states[i,1,:], color='blue', alpha=0.1)\n    plt.plot(trajectory.ts, trajectory.states[i,0,:], color='gold', alpha=0.1)\nplt.xlabel(\"Time (hours)\")\nplt.ylabel(\"State\")\nplt.title(\"Forger99 model (batch) in darkness\")\nplt.show();\n\n\n\n\nBecause adding a batch dimension is just using larger numpy arrays with the same vectorized operations under the hood we can run fairly larg batches with very little performance cost\n\n@benchmark\ndef batched_run(batch_size: int):\n    initial_conditions_batch = np.array([0.10,-0.10,0.0]) + np.random.normal(0, 0.1, (batch_size,3))\n    sol = fmodel.integrate_model(ts, \n                             light_values, \n                             state=initial_conditions_batch)\n\nfor i in [1,10,100,500,1000, 5000]:\n    batched_run(i)\n\nFunction batched_run(1,) {} Took 0.1166 seconds\nFunction batched_run(10,) {} Took 0.1125 seconds\nFunction batched_run(100,) {} Took 0.1285 seconds\nFunction batched_run(500,) {} Took 0.1895 seconds\nFunction batched_run(1000,) {} Took 0.2711 seconds\nFunction batched_run(5000,) {} Took 0.9169 seconds\n\n\nWe can also easily get predictions of the Dim Light Melatonin Onset (DLMO) and Core Body Temperature minimum (CBT). The time between these markers gives the period of the oscillator over that time frame.\n\nts = np.arange(0, 24*7, 0.1)\nlight_values = np.zeros_like(ts) \nfmodel = Forger99Model()\n\ntrajectory = fmodel(ts, light_values, state=np.array([0.10,-0.10,0.0]))\n\ncbt = fmodel.cbt(trajectory)\ndlmos = fmodel.dlmos(trajectory)\n\nprint(f\"Hours between CBTs: {np.diff(cbt)}\")\nprint(f\"Hours between DLMOs: {np.diff(dlmos)}\")\n\nHours between CBTs: [24.3 24.1 24.2 24.1 24.2 24.2]\nHours between DLMOs: [24.3 24.1 24.2 24.1 24.2 24.2]\n\n\nThe values away from 24.2 give the period while the transients die away from the initial conditions, you can see that the freerunning period (period with no light time cues) is 24.2 which roughly matches the average value from experimental studies.\nWe can adjust this by passing in a custom parameter for \\(\\tau_x\\) (taux)\n\nfmodel_short_period = Forger99Model({ 'taux': 23.8})\n\ntrajectory = fmodel_short_period.integrate_model(ts,light_est=light_values, state=np.array([0.10,-0.10,0.0]))\n\ndlmos = fmodel_short_period.dlmos(trajectory)\ncbt = fmodel_short_period.cbt(trajectory)\n\nprint(f\"Hours between DLMOs: {np.diff(dlmos)}\")\nprint(f\"Hours between CBTs: {np.diff(cbt)}\")\n\nHours between DLMOs: [23.8 23.8 23.7 23.8 23.8 23.8]\nHours between CBTs: [23.8 23.8 23.7 23.8 23.8 23.8]"
  },
  {
    "objectID": "models.html#hannay19tp",
    "href": "models.html#hannay19tp",
    "title": "Models",
    "section": "Hannay19TP",
    "text": "Hannay19TP\nThis model defines the two population model from (Hannay, Booth, and Forger 2019).Note, this model rotates counterclockwise in accordance with the usual convention in mathematics. The VDP family of models rotate clockwise. This can be confusing when trying to compare phase plane plots between the models, but is fixable with a simple rotation.\n\nsource\n\nHannay19TP\n\n Hannay19TP (params:dict=None)\n\nThe Hannay et al 2019 two population model, which models the ventral and dorsal SCN populations\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nparams\ndict\nNone\nDict of parameters to set, the published values are used by default\n\n\nReturns\nNone\n\n\n\n\n\n\nsource\n\n\nHannay19TP.derv\n\n Hannay19TP.derv (y:numpy.ndarray, light:float)\n\n\n\n\n\n\n\n\n\n\nType\nDetails\n\n\n\n\ny\nndarray\nstate vector for the dynamical system (Rv, Rd, Psiv, Psid, n)\n\n\nlight\nfloat\nlight intensity in lux\n\n\nReturns\nndarray\nderivative of the state vector"
  },
  {
    "objectID": "models.html#hannay19",
    "href": "models.html#hannay19",
    "title": "Models",
    "section": "Hannay19",
    "text": "Hannay19\nThis file defines the Hannay et al single population model from (Hannay, Booth, and Forger 2019). It describes the circadian state using polar coordinates \\((R, \\psi)\\) and features a slight modification of the process L light processing function used in the VDP family of models (Forger, Jewett, and Kronauer 1999). The model is systematically derived from a high-dimensional model for each clock neuron (Hannay, Forger, and Booth 2018).\nHere are some marker states for that model (all equals should be read as approx)\nCBT=DLMO+7hrs CBT=DLMO_mid+2hrs CBT=circadian phase pi in the model DLMO=circadian phase 5pi/12=1.309 in the model MelatoninOffset=DLMO+10hrs\n\nsource\n\nHannay19\n\n Hannay19 (params:dict=None)\n\nA simple python program to integrate the human circadian rhythms model (Hannay et al 2019) for a given light schedule\n\nspmodel = Hannay19()\ndefault_ic = spmodel.default_initial_conditions\n\n\nspmodel = Hannay19()\nts = np.arange(0, 24*7, 0.10)\nlight_values = np.zeros(len(ts))\ntrajectory= spmodel(ts, light_values, np.array([0.10, 0.0,0.0]))\n\nplt.plot(trajectory.states[0,:]*np.cos(trajectory.states[1,:]), trajectory.states[0,:]*np.sin(trajectory.states[1,:]))\nplt.title(\"Phase plot of the Hannay19 model\")\nplt.xlabel(\"R cos(Psi)\")\nplt.xlabel(\"R sin(Psi)\")\n\nText(0.5, 0, 'R sin(Psi)')\n\n\n\n\n\nBecause of the way the integration code is written it is simple to run a collection of initial conditions through the model by just adding an batch dimension (terminology taken from the machine learning literature). This shows an example of running the model through\n\nfrom circadian.lights import *  \n\nspmodel = Hannay19()\n\nts = np.arange(0, 24*5, 0.10)\nlight_func = Light.ShiftWorkLight(dayson=3, daysoff=4)\nlight_values = light_func(ts)\nnum_batches = 100\ninitial_conditions_batch = np.array([0.70, np.pi,0.0]) + np.random.randn(num_batches,3)*0.20\n\ntrajectory = spmodel(ts, light_values, initial_conditions_batch)\nfor batch_idx in range(num_batches):\n    plt.plot(trajectory.ts / 24.0, trajectory.states[batch_idx, 0,:]*np.sin(trajectory.states[batch_idx,1,:]), color='blue', alpha=0.10)\nplt.title(f\"{num_batches} batches of initial conditions\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"R sin(Psi)\");\n\n\n\n\n\nplt.hist((trajectory.states[:,1,-1] - np.mean(trajectory.states[:,1,-1])) , bins=20, color='blue', alpha=0.5, label=\"Ending phase dispersion\");\nplt.hist((trajectory.states[:,1,0] - np.mean(trajectory.states[:,1,0])) , bins=20, color='green', alpha=0.5, label=\"Starting phase dispersion\");\nplt.legend();\n\n\n\n\nWe can also easily run the model over an batch of parameters just by passing in an array for the value of the parameters. The only gotcha is that you also need to pass in initial conditions which the same batch dimension to ensure the array arithmetic works out in the integrator.\n\nnum_batches = 100\nspmodel = Hannay19({ 'tau' : np.linspace(23.5,24.5, num_batches), 'A1' : 0.32 + 0.05*np.random.randn(num_batches) })\ninitial_conditions_batch = np.array([0.70, np.pi,0.0]) + np.zeros((num_batches,3))\nlight_func = Light.ShiftWorkLight(dayson=2, daysoff=5)\nts = np.arange(0, 24*14, 0.10)\nlight_values = light_func(ts, repeat_period=24.0*7)\ntrajectory = spmodel.integrate_model(ts, light_est=light_values, state=initial_conditions_batch)\nfor batch_idx in range(num_batches):\n    plt.plot(trajectory.ts / 24.0, trajectory.states[batch_idx, 0,:]*np.sin(trajectory.states[batch_idx,1,:]), color='blue', alpha=0.10)\nplt.title(f\"{num_batches} batches of parameters\")\nplt.xlabel(\"Time (days)\")\nplt.ylabel(\"R sin(Psi)\");"
  },
  {
    "objectID": "models.html#models-coming-soon",
    "href": "models.html#models-coming-soon",
    "title": "Models",
    "section": "Models Coming Soon",
    "text": "Models Coming Soon"
  },
  {
    "objectID": "models.html#non-photic-model-hilaire-2007",
    "href": "models.html#non-photic-model-hilaire-2007",
    "title": "Models",
    "section": "Non Photic Model ( Hilaire 2007)",
    "text": "Non Photic Model ( Hilaire 2007)\nThis implements the model from (Hilaire et al. 2007). It describes the circadian state using the \\((x, x_c, n)\\) variables as seen in the other VDP based models. This model also uses sleep-wake information as a non-photic input.\n\nsource\n\nHilaire2007\n\n Hilaire2007 (params:dict=None)\n\nAbstract base class for circadian models, defines the interface for all models\n\nhmodel = Hilaire2007() \n\nprint(hmodel.derv(0, hmodel.default_initial_conditions, 1000, 1.0))\nprint(hmodel.step_rk4(0, hmodel.default_initial_conditions, 1000, 1.0))\n\n[ 0.16975025 -0.02067777  1.76968823]\n[-0.28695536 -1.13159738  0.15893028]\n\n\n\nsol = hmodel.integrate_model(np.arange(0, 24*100, 0.1),\n                             np.random.rand(240*100), \n                             np.random.rand(240*100), \n                             hmodel.default_initial_conditions)\n\nplt.plot(sol.states[0, :], sol.states[1,:]);\nplt.title(hmodel.__str__());\nplt.xlabel(\"x\");\nplt.ylabel(\"$x_c$\");"
  },
  {
    "objectID": "models.html#kronauer-jewett-model",
    "href": "models.html#kronauer-jewett-model",
    "title": "Models",
    "section": "Kronauer-Jewett Model",
    "text": "Kronauer-Jewett Model\nFrom the revised limit cycle oscillator model paper.\n\nsource\n\nKronauerJewett\n\n KronauerJewett (params:dict=None)\n\nHigher order vdp model for the circadian clock\n\nkmodel = KronauerJewett({\"taux\": np.linspace(23.5,24.5, 100)})\n\nic = kmodel.default_initial_conditions + np.zeros((100, 3))\nsim_days = 10\nsol = kmodel(ts=np.arange(0, 24*sim_days, 0.1), light_est=np.zeros(240*sim_days), state=ic)\n\nfor batch_idx in range(sol.batch_size):\n    plt.plot(sol.ts, sol.states[batch_idx, 1,:], color=\"darkgreen\", alpha=0.1)\n\n\n\n\n\nnp.diff(kmodel.cbt(sol.get_batch(0)))\n\narray([24. , 23.5, 23.5, 23.5, 23.5, 23.5, 23.5, 23.5, 23.5, 23.5])\n\n\n\nnp.diff(kmodel.dlmos(sol.get_batch(0)))\n\narray([24. , 23.5, 23.5, 23.5, 23.5, 23.5, 23.5, 23.5, 23.5, 23.5])"
  },
  {
    "objectID": "models.html#phase-dynamics-model-nakao02",
    "href": "models.html#phase-dynamics-model-nakao02",
    "title": "Models",
    "section": "Phase Dynamics Model Nakao02",
    "text": "Phase Dynamics Model Nakao02\nmodel\n\nReferences\n\n\nForger, Daniel B., Megan E. Jewett, and Richard E. Kronauer. 1999. “A Simpler Model of the Human Circadian Pacemaker.” Journal of Biological Rhythms 14 (6): 533–38. https://doi.org/10.1177/074873099129000867.\n\n\nHannay, Kevin M., Victoria Booth, and Daniel B. Forger. 2019. “Macroscopic Models for Human Circadian Rhythms.” Journal of Biological Rhythms, October, 074873041987829. https://doi.org/10.1177/0748730419878298.\n\n\nHannay, Kevin M., Daniel B. Forger, and Victoria Booth. 2018. “Macroscopic Models for Networks of Coupled Biological Oscillators.” Science Advances 4 (8): e1701047. https://doi.org/10.1126/sciadv.1701047.\n\n\nHilaire, M. A St, Elizabeth B. Klerman, S. B S Khalsa, Kenneth P. Wright, Charles A. Czeisler, and Richard E. Kronauer. 2007. “Addition of a Non-Photic Component to a Light-Based Mathematical Model of the Human Circadian Pacemaker.” Journal of Theoretical Biology 247 (4): 583–99. https://doi.org/10.1016/j.jtbi.2007.04.001.\n\n\nSerkh, Kirill, and Daniel B. Forger. 2014. “Optimal Schedules of Light Exposure for Rapidly Correcting Circadian Misalignment.” PLOS Computational Biology 10 (4): e1003523. https://doi.org/10.1371/journal.pcbi.1003523."
  }
]